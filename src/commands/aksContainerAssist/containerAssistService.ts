import * as vscode from "vscode";
import { Errorable, failed } from "../utils/errorable";
import { AnalyzeRepositoryResult, ContainerAssistResult, DockerfilePlan, ManifestPlan } from "./types";
import * as l10n from "@vscode/l10n";
import { createApp, AppRuntime } from "containerization-assist-mcp";
import * as fs from "fs";
import * as path from "path";

/**
 * Service for interacting with Container Assist MCP tools
 */
export class ContainerAssistService {
    private appRuntime: AppRuntime | null = null;

    /**
     * Initialize the Container Assist app runtime
     */
    private async initializeRuntime(): Promise<Errorable<AppRuntime>> {
        if (this.appRuntime) {
            return { succeeded: true, result: this.appRuntime };
        }

        try {
            this.appRuntime = await createApp();
            return { succeeded: true, result: this.appRuntime };
        } catch (error) {
            return {
                succeeded: false,
                error: l10n.t("Failed to initialize Container Assist runtime: {0}", String(error)),
            };
        }
    }

    /**
     * Check if Container Assist tools are available
     */
    async isAvailable(): Promise<Errorable<boolean>> {
        try {
            // Check if the containerAssistEnabledPreview setting is enabled
            const config = vscode.workspace.getConfiguration("aks");
            const isEnabled = config.get<boolean>("containerAssistEnabledPreview", false);

            if (!isEnabled) {
                return {
                    succeeded: false,
                    error: l10n.t(
                        "Container Assist is not enabled. Please enable 'aks.containerAssistEnabledPreview' in settings.",
                    ),
                };
            }

            // Check if we can initialize the runtime
            const runtime = await this.initializeRuntime();
            if (failed(runtime)) {
                return {
                    succeeded: false,
                    error: runtime.error,
                };
            }

            return { succeeded: true, result: true };
        } catch (error) {
            return {
                succeeded: false,
                error: l10n.t("Failed to check Container Assist availability: {0}", String(error)),
            };
        }
    }

    /**
     * Analyze the repository to determine language, framework, and other metadata
     */
    async analyzeRepository(folderPath: string): Promise<Errorable<AnalyzeRepositoryResult>> {
        try {
            const runtime = await this.initializeRuntime();
            if (failed(runtime)) {
                return {
                    succeeded: false,
                    error: runtime.error,
                };
            }

            vscode.window.showInformationMessage(
                l10n.t("Container Assist: Analyzing repository at {0}...", folderPath),
            );

            // Call the analyze-repo tool with correct parameter name
            const result = await runtime.result.execute("analyze-repo" as never, {
                repositoryPath: folderPath,
            } as never);

            if (!result.ok) {
                return {
                    succeeded: false,
                    error: l10n.t("Failed to analyze repository: {0}", String(result.error)),
                };
            }

            const analysis = result.value as {
                language?: string;
                framework?: string;
                port?: number;
                buildCommand?: string;
                startCommand?: string;
                modules?: Array<{
                    name: string;
                    path: string;
                    language?: string;
                    framework?: string;
                }>;
            };

            return {
                succeeded: true,
                result: {
                    language: analysis.language,
                    framework: analysis.framework,
                    port: analysis.port,
                    buildCommand: analysis.buildCommand,
                    startCommand: analysis.startCommand,
                },
            };
        } catch (error) {
            return {
                succeeded: false,
                error: l10n.t("Failed to analyze repository: {0}", String(error)),
            };
        }
    }

    /**
     * Build Dockerfile content from a DockerfilePlan
     */
    private buildDockerfileFromPlan(plan: DockerfilePlan, analysisResult: AnalyzeRepositoryResult): string {
        const lines: string[] = [];
        const repoInfo = plan.repositoryInfo;
        const recommendations = plan.recommendations;

        // Add header comment
        lines.push("# Generated by Container Assist for AKS");
        lines.push(`# Language: ${repoInfo.language || "auto-detected"}`);
        if (repoInfo.framework) {
            lines.push(`# Framework: ${repoInfo.framework}`);
        }
        lines.push("");

        // Determine base image
        let baseImage = "node:20-alpine"; // Default fallback
        if (recommendations.baseImages && recommendations.baseImages.length > 0) {
            baseImage = recommendations.baseImages[0].image;
        } else if (repoInfo.language) {
            // Language-specific defaults
            const lang = repoInfo.language.toLowerCase();
            if (lang.includes("python")) {
                baseImage = "python:3.11-slim";
            } else if (lang.includes("node") || lang.includes("javascript") || lang.includes("typescript")) {
                baseImage = "node:20-alpine";
            } else if (lang.includes("go")) {
                baseImage = "golang:1.21-alpine";
            } else if (lang.includes("java")) {
                baseImage = "eclipse-temurin:17-jre-alpine";
            } else if (lang.includes("dotnet") || lang.includes("csharp")) {
                baseImage = "mcr.microsoft.com/dotnet/aspnet:8.0-alpine";
            }
        }

        lines.push(`FROM ${baseImage}`);
        lines.push("");

        // Set working directory
        lines.push("WORKDIR /app");
        lines.push("");

        // Apply security considerations - run as non-root user
        const hasNonRootUser = recommendations.securityConsiderations.some((req) =>
            req.recommendation.toLowerCase().includes("non-root"),
        );
        if (hasNonRootUser) {
            lines.push("# Run as non-root user for security");
            lines.push("RUN addgroup -g 1001 -S appgroup && adduser -u 1001 -S appuser -G appgroup");
            lines.push("");
        }

        // Copy package files first (for better caching)
        if (repoInfo.language?.toLowerCase().includes("node")) {
            lines.push("# Copy package files");
            lines.push("COPY package*.json ./");
            lines.push("");
            lines.push("# Install dependencies");
            lines.push("RUN npm ci --only=production");
            lines.push("");
        } else if (repoInfo.language?.toLowerCase().includes("python")) {
            lines.push("# Copy requirements");
            lines.push("COPY requirements.txt ./");
            lines.push("");
            lines.push("# Install dependencies");
            lines.push("RUN pip install --no-cache-dir -r requirements.txt");
            lines.push("");
        } else if (repoInfo.language?.toLowerCase().includes("go")) {
            lines.push("# Copy go mod files");
            lines.push("COPY go.mod go.sum ./");
            lines.push("");
            lines.push("# Download dependencies");
            lines.push("RUN go mod download");
            lines.push("");
        }

        // Copy application files
        lines.push("# Copy application files");
        lines.push("COPY . .");
        lines.push("");

        // Apply optimizations - remove unnecessary files
        const hasCleanup = recommendations.optimizations.some((req) =>
            req.recommendation.toLowerCase().includes("cache") || req.recommendation.toLowerCase().includes("cleanup"),
        );
        if (hasCleanup) {
            lines.push("# Clean up unnecessary files");
            lines.push("RUN rm -rf .git .gitignore README.md *.md");
            lines.push("");
        }

        // Change ownership to non-root user if applicable
        if (hasNonRootUser) {
            lines.push("RUN chown -R appuser:appgroup /app");
            lines.push("USER appuser");
            lines.push("");
        }

        // Expose port
        const port = repoInfo.port || analysisResult.port || 8080;
        lines.push(`EXPOSE ${port}`);
        lines.push("");

        // Add health check if recommended
        const hasHealthCheck = recommendations.bestPractices.some((req) =>
            req.recommendation.toLowerCase().includes("healthcheck"),
        );
        if (hasHealthCheck) {
            lines.push("# Health check");
            lines.push(`HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\`);
            lines.push(`  CMD wget --no-verbose --tries=1 --spider http://localhost:${port}/health || exit 1`);
            lines.push("");
        }

        // Start command
        let cmd = "npm start";
        if (repoInfo.startCommand) {
            cmd = repoInfo.startCommand;
        } else if (repoInfo.language?.toLowerCase().includes("python")) {
            cmd = "python app.py";
        } else if (repoInfo.language?.toLowerCase().includes("go")) {
            cmd = "./app";
        }

        // Build CMD as array format
        const cmdParts = cmd.split(" ");
        if (cmdParts.length === 1) {
            lines.push(`CMD ["${cmdParts[0]}"]`);
        } else {
            const cmdArray = cmdParts.map((part) => `"${part}"`).join(", ");
            lines.push(`CMD [${cmdArray}]`);
        }

        return lines.join("\n");
    }

    /**
     * Build Kubernetes manifest content from a ManifestPlan
     */
    private buildManifestsFromPlan(plan: ManifestPlan, appName: string): Array<{ path: string; content: string }> {
        const manifests: Array<{ path: string; content: string }> = [];
        const repoInfo = plan.repositoryInfo;
        const port = repoInfo?.ports?.[0] || 8080;

        // Generate Deployment manifest
        const deploymentLines: string[] = [];
        deploymentLines.push("apiVersion: apps/v1");
        deploymentLines.push("kind: Deployment");
        deploymentLines.push("metadata:");
        deploymentLines.push(`  name: ${appName}`);
        deploymentLines.push(`  namespace: default`);
        deploymentLines.push("  labels:");
        deploymentLines.push(`    app: ${appName}`);
        deploymentLines.push("spec:");
        deploymentLines.push("  replicas: 1");
        deploymentLines.push("  selector:");
        deploymentLines.push("    matchLabels:");
        deploymentLines.push(`      app: ${appName}`);
        deploymentLines.push("  template:");
        deploymentLines.push("    metadata:");
        deploymentLines.push("      labels:");
        deploymentLines.push(`        app: ${appName}`);
        deploymentLines.push("    spec:");
        deploymentLines.push("      containers:");
        deploymentLines.push(`      - name: ${appName}`);
        deploymentLines.push(`        image: ${appName}:latest`);
        deploymentLines.push("        ports:");
        deploymentLines.push(`        - containerPort: ${port}`);
        deploymentLines.push("        resources:");
        deploymentLines.push("          requests:");
        deploymentLines.push("            cpu: 100m");
        deploymentLines.push("            memory: 128Mi");
        deploymentLines.push("          limits:");
        deploymentLines.push("            cpu: 500m");
        deploymentLines.push("            memory: 512Mi");

        // Add liveness and readiness probes if recommended
        const hasHealthCheck = plan.recommendations.bestPractices.some((req) =>
            req.recommendation.toLowerCase().includes("health") || req.recommendation.toLowerCase().includes("probe"),
        );
        if (hasHealthCheck) {
            deploymentLines.push("        livenessProbe:");
            deploymentLines.push("          httpGet:");
            deploymentLines.push(`            path: /health`);
            deploymentLines.push(`            port: ${port}`);
            deploymentLines.push("          initialDelaySeconds: 30");
            deploymentLines.push("          periodSeconds: 10");
            deploymentLines.push("        readinessProbe:");
            deploymentLines.push("          httpGet:");
            deploymentLines.push(`            path: /health`);
            deploymentLines.push(`            port: ${port}`);
            deploymentLines.push("          initialDelaySeconds: 5");
            deploymentLines.push("          periodSeconds: 5");
        }

        // Add security context if recommended
        const hasSecurityContext = plan.recommendations.securityConsiderations.some(
            (req) => req.recommendation.toLowerCase().includes("non-root") || req.recommendation.toLowerCase().includes("security"),
        );
        if (hasSecurityContext) {
            deploymentLines.push("        securityContext:");
            deploymentLines.push("          runAsNonRoot: true");
            deploymentLines.push("          runAsUser: 1001");
            deploymentLines.push("          allowPrivilegeEscalation: false");
            deploymentLines.push("          capabilities:");
            deploymentLines.push("            drop:");
            deploymentLines.push("            - ALL");
        }

        manifests.push({
            path: "deployment.yaml",
            content: deploymentLines.join("\n"),
        });

        // Generate Service manifest
        const serviceLines: string[] = [];
        serviceLines.push("apiVersion: v1");
        serviceLines.push("kind: Service");
        serviceLines.push("metadata:");
        serviceLines.push(`  name: ${appName}`);
        serviceLines.push(`  namespace: default`);
        serviceLines.push("  labels:");
        serviceLines.push(`    app: ${appName}`);
        serviceLines.push("spec:");
        serviceLines.push("  type: ClusterIP");
        serviceLines.push("  selector:");
        serviceLines.push(`    app: ${appName}`);
        serviceLines.push("  ports:");
        serviceLines.push(`  - port: ${port}`);
        serviceLines.push(`    targetPort: ${port}`);
        serviceLines.push("    protocol: TCP");
        serviceLines.push(`    name: http`);

        manifests.push({
            path: "service.yaml",
            content: serviceLines.join("\n"),
        });

        return manifests;
    }

    /**
     * Generate a Dockerfile for the repository
     */
    async generateDockerfile(folderPath: string, analysisResult: AnalyzeRepositoryResult): Promise<Errorable<string>> {
        try {
            const runtime = await this.initializeRuntime();
            if (failed(runtime)) {
                return {
                    succeeded: false,
                    error: runtime.error,
                };
            }

            vscode.window.showInformationMessage(
                l10n.t("Container Assist: Generating Dockerfile for {0}...", folderPath),
            );

            // Call the generate-dockerfile tool to get a plan
            const result = await runtime.result.execute("generate-dockerfile" as never, {
                repositoryPath: folderPath,
                language: analysisResult.language,
                framework: analysisResult.framework,
                environment: "production",
                targetPlatform: "linux/amd64",
            } as never);

            if (!result.ok) {
                return {
                    succeeded: false,
                    error: l10n.t("Failed to generate Dockerfile: {0}", String(result.error)),
                };
            }

            // The tool returns a DockerfilePlan, not the actual Dockerfile content
            const plan = result.value as DockerfilePlan;

            // Validate that we got a plan with recommendations
            if (!plan.recommendations || !plan.nextAction) {
                return {
                    succeeded: false,
                    error: l10n.t(
                        "Invalid Dockerfile plan received. Missing recommendations or nextAction. Response: {0}",
                        JSON.stringify(result.value),
                    ),
                };
            }

            // Build Dockerfile content from the plan
            const dockerfileContent = this.buildDockerfileFromPlan(plan, analysisResult);

            // Write the Dockerfile to the repository
            const dockerfilePath = path.join(folderPath, "Dockerfile");
            await fs.promises.writeFile(dockerfilePath, dockerfileContent, "utf-8");

            vscode.window.showInformationMessage(
                l10n.t("Successfully generated Dockerfile with {0} recommendations", 
                    plan.recommendations.baseImages.length + 
                    plan.recommendations.securityConsiderations.length + 
                    plan.recommendations.optimizations.length + 
                    plan.recommendations.bestPractices.length
                ),
            );

            return {
                succeeded: true,
                result: dockerfilePath,
            };
        } catch (error) {
            return {
                succeeded: false,
                error: l10n.t("Failed to generate Dockerfile: {0}", String(error)),
            };
        }
    }

    /**
     * Generate Kubernetes manifests for the application
     */
    async generateManifests(
        folderPath: string,
        _dockerfilePath: string,
        appName: string,
    ): Promise<Errorable<string[]>> {
        try {
            const runtime = await this.initializeRuntime();
            if (failed(runtime)) {
                return {
                    succeeded: false,
                    error: runtime.error,
                };
            }

            vscode.window.showInformationMessage(
                l10n.t("Container Assist: Generating Kubernetes manifests for {0}...", appName),
            );

            // Call the generate-k8s-manifests tool to get a plan
            const result = await runtime.result.execute("generate-k8s-manifests" as never, {
                name: appName,
                manifestType: "kubernetes",
                environment: "production",
                namespace: "default",
                ports: [8080],
                includeComments: true,
            } as never);

            if (!result.ok) {
                return {
                    succeeded: false,
                    error: l10n.t("Failed to generate Kubernetes manifests: {0}", String(result.error)),
                };
            }

            // The tool returns a ManifestPlan, not the actual manifest files
            const plan = result.value as ManifestPlan;

            // Validate that we got a plan with recommendations
            if (!plan.recommendations || !plan.nextAction) {
                return {
                    succeeded: false,
                    error: l10n.t(
                        "Invalid manifest plan received. Missing recommendations or nextAction. Response: {0}",
                        JSON.stringify(result.value),
                    ),
                };
            }

            // Build manifest content from the plan
            const manifestFiles = this.buildManifestsFromPlan(plan, appName);

            // Create k8s directory
            const k8sDir = path.join(folderPath, "k8s");
            if (!fs.existsSync(k8sDir)) {
                await fs.promises.mkdir(k8sDir, { recursive: true });
            }

            // Write manifest files
            const manifestPaths: string[] = [];
            for (const manifest of manifestFiles) {
                const filePath = path.join(k8sDir, manifest.path);
                await fs.promises.writeFile(filePath, manifest.content, "utf-8");
                manifestPaths.push(filePath);
            }

            vscode.window.showInformationMessage(
                l10n.t(
                    "Successfully generated {0} Kubernetes manifest(s) with {1} recommendations",
                    manifestFiles.length,
                    plan.recommendations.securityConsiderations.length +
                        (plan.recommendations.resourceManagement?.length || 0) +
                        plan.recommendations.bestPractices.length,
                ),
            );

            return {
                succeeded: true,
                result: manifestPaths,
            };
        } catch (error) {
            return {
                succeeded: false,
                error: l10n.t("Failed to generate Kubernetes manifests: {0}", String(error)),
            };
        }
    }

    /**
     * Execute the complete deployment generation workflow
     * This orchestrates: Analyze → Generate Dockerfile → Generate K8s Manifests
     */
    async generateDeploymentFiles(folderPath: string, appName: string): Promise<ContainerAssistResult> {
        // Step 1: Analyze the repository
        const analysisResult = await this.analyzeRepository(folderPath);
        if (failed(analysisResult)) {
            return {
                succeeded: false,
                error: analysisResult.error,
            };
        }

        // Step 2: Generate Dockerfile
        const dockerfileResult = await this.generateDockerfile(folderPath, analysisResult.result);
        if (failed(dockerfileResult)) {
            return {
                succeeded: false,
                error: dockerfileResult.error,
            };
        }

        // Step 3: Generate Kubernetes manifests
        const manifestsResult = await this.generateManifests(folderPath, dockerfileResult.result, appName);
        if (failed(manifestsResult)) {
            return {
                succeeded: false,
                error: manifestsResult.error,
            };
        }

        return {
            succeeded: true,
            generatedFiles: [dockerfileResult.result, ...manifestsResult.result],
        };
    }
}
